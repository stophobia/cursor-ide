---
description: [한글] 모두의커서 지시사항 
globs: 
---
# 개발 지시사항 

---

## 1. 기본 원칙 및 스타일

- **간결하고 기술적인 응답 작성**  
  필수적인 Python 예시 코드 등을 포함하며, 정확한 문법과 개념을 사용합니다.

- **클래스 기반 프로그래밍 선호**  
  - 클래스 기반의 코드를 작성해야 합니다.
  - 반복적인 코드 대신 모듈화를 통해 중복을 최소화합니다.

- **명확한 변수 및 함수 네이밍**  
  - 변수, 함수 등은 is_active, has_permission과 같이 보조 동사를 활용한 이름 사용
  - 파일 및 폴더는 소문자와 언더스코어(snake_case) 형식을 따릅니다.  
    예: `routers/user_routes.py`, `utils/data_processing.py`

- **RORO (Receive an Object, Return an Object) 패턴 준수**  
  모든 함수는 입력을 Pydantic v2 모델로 받고, 결과값도 객체로 반환합니다.

---

## 2. Python / FastAPI 개발 가이드

### 2.1 함수 및 비동기 작업
- 일반 함수는 `def`를 사용하고, 비동기 작업은 `async def`를 사용합니다.
- 함수 시그니처에 타입 힌트를 명시하며, Pydantic v2 모델을 사용하여 입력 데이터 검증 및 응답 스키마를 구성합니다.
- API 경로(Route)는 선언적으로 구성하며, 명시적인 return 타입을 지정합니다.

### 2.2 에러 핸들링 및 검증
- 모든 에러와 엣지 케이스는 함수 초반에 처리(Guard Clause)를 사용합니다.  
  예: 입력 데이터 검증 실패 시 빠른 반환(early return) 패턴 활용
- try/except 구문을 사용하여 예상치 못한 오류를 잡고, 사용자 친화적인 에러 메시지와 함께 적절한 HTTPException을 발생시킵니다.
- 커스텀 에러 타입과 에러 팩토리를 사용하여 일관된 에러 처리를 구현합니다.
- 내부 디버깅 정보와 스택 트레이스는 별도의 로깅 처리를 합니다.

### 2.3 모듈 구성 및 파일 구조
- **라우터(Router)**:  
  API 엔드포인트를 기능별로 분리하여 라우터 모듈에서 정의합니다.
- **유틸리티(Utilities)**:  
  반복적이거나 공통 사용되는 로직은 유틸리티 함수로 분리하여 관리합니다.
- **타입/모델**:  
  데이터 검증 및 스키마 관리를 위해 Pydantic v2 모델을 사용합니다.
- **외부 의존성 주입**:  
  FastAPI의 Dependency Injection을 활용하여, 데이터베이스 연결, 캐싱(Redis), 환경 변수 등을 관리합니다.

---

## 3. 성능 최적화 및 비동기 처리
- **비동기 I/O 최적화**:  
  데이터베이스(asyncpg, psycopg2, SQLAlchemy 2) 및 외부 API 호출을 비동기 함수로 처리하여 블로킹을 최소화합니다.
- **캐싱 전략**:  
  Redis 및 fastapi-cache2 라이브러리를 활용하여 빈번한 데이터 호출을 캐싱 처리합니다.
- **데이터 직렬화 최적화**:  
  Pydantic v2를 통한 데이터 직렬화/역직렬화 최적화 및 lazy loading 기법을 적용합니다.
- **미들웨어 활용**:  
  로깅, 오류 모니터링, 성능 최적화를 위한 미들웨어를 구현하며, FastAPI의 Lifespan Context Manager를 사용하여 startup/shutdown 이벤트를 관리합니다.

---

## 4. 마이크로서비스 및 서버리스 아키텍처
- **무상태(stateless) 서비스 디자인**:  
  서비스는 내부 상태를 저장하지 않고 외부 스토리지 및 캐시에 의존합니다.
- **API 게이트웨이 및 리버스 프록시**:  
  AWS API Gateway, NGINX 등을 활용하여 트래픽 조절, 요청 변환, 보안 처리를 수행합니다.
- **내부 통신 및 메시지 브로커**:  
  RabbitMQ, Kafka 등의 메시지 브로커를 활용하여 비동기 이벤트 기반 통신을 구현합니다.

---

## 5. 고급 미들웨어 및 보안
- **보안 최적화**:  
  - OAuth2 인증, CORS, CSP 등 보안 헤더를 적용하여 API 보안을 강화합니다.
  - JWT 토큰 관리, CSRF 방어, 입력 데이터XSS/SQL Injection 방어 전략을 구체화합니다.
  - API Rate Limiting 및 DDoS 방어를 위한 미들웨어 구현 가이드를 포함합니다.
- **로깅 및 예외처리**:  
  - 커스텀 예외 클래스를 정의하고, 각 에러 상황별 로그 레벨(debug, info, warning, error, critical)에 따른 작성 가이드를 마련합니다.
  - 로깅 메시지에 request ID, 사용자 정보, 호출 스택 등의 정보를 포함하여 디버깅 및 모니터링을 강화합니다.

---

## 6. 환경 변수 및 설정 관리 강화
- **pydantic-settings 활용**:  
  환경 변수 관리를 위해 pydantic-settings를 사용하며, 구체적인 예제 및 설정 파일 구조를 문서화합니다.
  - 예제: `.env` 파일과 설정 모델 클래스를 활용하여 로컬, 스테이징, 프로덕션 환경별 설정을 분리합니다.
- **설정 분리 전략**:  
  각 환경별로 별도의 설정 파일(예: settings_local.py, settings_staging.py, settings_prod.py)을 구성하여 관리합니다.

---

## 7. 문서화 및 주석 표준
- **Docstring 작성 규칙**:  
  각 클래스, 함수, 모듈에는 상세한 Docstring을 작성하며, 비즈니스 로직 및 주요 알고리즘의 의도를 명확히 전달합니다.
- **주석 가이드라인**:  
  주석은 단순 설명을 넘어서, 코드의 핵심 로직과 의도를 문서화합니다.

---

## 8. 정적 분석 및 린팅 도구 활용
- **기존 도구 외 추가 도구 활용**:  
  black, isort, mypy, ruff 외에 flake8, bandit 등을 사용하여 보안 취약점 검색 및 코드 품질 검증을 강화합니다.
- **CI/CD 파이프라인**:  
  정적 분석 도구를 CI/CD 파이프라인에 포함시켜, 자동화된 코드 리뷰 및 품질 검증을 수행합니다.

---

## 9. 클래스 기반의 구조 세분화
- **클래스 분리 지침**:  
  각 도메인 별로 서비스 클래스, 컨트롤러(또는 라우터) 클래스, 유틸리티 클래스로 명확하게 분리합니다.
- **패턴 및 예제 코드**:  
  서비스 레이어, 리포지토리 패턴 등 구체적인 패턴을 예시 코드와 함께 문서화하여 팀원들이 일관되게 개발할 수 있도록 합니다.

---

## 10. PRD 문서 및 내부 지시사항 연동
- **PRD 문서별 역할**:  
  - 프로젝트 전체 PRD는 ' [MOAI_PRD.mdc](mdc:.cursor/rules/MOAI_PRD.mdc)' 지시사항을 따릅니다.
  - 도메인별 PRD (예: 사주, 계정, 사용자, 만세력)는 각 도메인의 상세 요구사항, API 스펙, 데이터 모델, 예외 처리 및 비즈니스 로직을 포함합니다.
- **문서 업데이트와 동기화**:  
  코드 변경(특히 DB 스키마, API 스펙) 시 PRD 문서 및 Alembic 스크립트, 관련 도메인 문서를 동기화합니다.
- **상수, 타입, 유틸리티 함수 관리**:  
  상수 및 공통 함수 변경 시 관련 문서를 업데이트하여 일관성을 유지합니다.

